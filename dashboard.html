<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Barissin</title>
  <link rel="icon" type="image/jpeg" href="images/logo_eau.jpg">
  <script src="https://unpkg.com/d3@7"></script>
  <!-- N'oubliez pas d'inclure Turf si besoin -->
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;700&display=swap');
    
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #3a7bd5, #00d2ff);
      color: white;
      text-align: center;
    }
    .button-container {
      text-align: center;
      margin-bottom: 20px;
      padding: 20px;
    }
    .button {
      background-color: white;
      color: #007BFF;
      padding: 12px 25px;
      margin: 5px;
      border: none;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      border-radius: 25px;
      text-decoration: none;
      display: inline-block;
      transition: all 0.3s ease-in-out;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }
    .button:hover {
      background-color: #007BFF;
      color: white;
    }
    .button.active {
      background-color: #0056b3;
      color: white;
      cursor: default;
    }
    #global-container {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 100vh;
    }
    #left-container {
      flex: 2;
      background-color: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 15px;
      padding: 10px;
    }
    #right-container {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }
    .chart-container {
      margin: 20px auto;
      position: relative;
    }
  </style>
</head>
<body>
  <h1 style="text-align:center">Rareté et pénurie de l'eau bleue</h1>
  <body>
    <div class="button-container">
      <a href="index.html" class="button">Accueil</a>
      <a href="presentation.html" class="button">Présentation du Projet</a>
      <a href="dashboard.html" class="button active">Dashboard</a>
    </div>
  
  <!-- Nouveau conteneur pour le lien Wikipédia -->
  <div id="wiki-link" style="text-align:center; margin-bottom:20px;"></div>
  <div id="global-container">
    <!-- Partie gauche  -->
    <div id="left-container"></div>
    <!-- Partie droite : Les graphiques -->
      <div id="right-container">
      <!-- Graphique Chart6 -->
      <div id="chart6-container" class="chart-container"></div>
      <!-- Graphique Chart7 -->
      <div id="chart7-container" class="chart-container"></div>
      <!-- Graphique ChartDiff -->
      <div id="chartDiff-container" class="chart-container"></div>
    </div>
  </div>

  <!-- Script pour insérer le graphique dans la partie gauche -->
  <script type="module">
    // Pour émuler la fonction 'html' d'Observable (très simple)
    const html = (strings, ...values) => {
      const template = document.createElement("template");
      template.innerHTML = String.raw({ raw: strings }, ...values);
      return template.content.firstElementChild;
    };

    // Votre graphique Observable, adapté pour le web classique
    async function createMap10() {
      const width = 960, height = 500;
      
      // Créer le conteneur qui regroupe le menu déroulant et la carte
      const container = html`
        <div style="width: ${width}px;">
          <!-- Menu déroulant pour sélectionner une zone -->
          <select id="drainage-select" style="
              width: ${width}px;
              height: 40px;
              font-size: 16px;
              margin-bottom: 5px;
          ">
            <option value="all">-- SELECT ALL --</option>
          </select>
          <!-- La carte (SVG) -->
          <svg width="${width}" height="${height}"></svg>
        </div>
      `;
      
      const selectEl = container.querySelector("#drainage-select");
      const svg = d3.select(container).select("svg");
      
      // Charger la carte du monde et vos données
      const world = await d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson");
      // Remplacez FileAttachment par un fetch si nécessaire ou fournissez le fichier localement
      const geoData = await d3.json("data/map.geojson");
      
      // Correction d’orientation des polygones avec Turf
      geoData.features = geoData.features.map(f => turf.rewind(f, { reverse: true }));
      
      // Calculer les zones distinctes (DRAINAGE) et les trier
      const drainageZones = Array.from(new Set(geoData.features.map(d => d.properties.DRAINAGE))).sort();
      drainageZones.forEach(zone => {
        const option = document.createElement("option");
        option.value = zone;
        option.textContent = zone;
        selectEl.appendChild(option);
      });
      
      // Combiner les données pour ajuster la projection
      const combined = {
        type: "FeatureCollection",
        features: [...world.features, ...geoData.features]
      };
      
      // Définir la projection Natural Earth et ajuster sa taille
      const projection = d3.geoNaturalEarth1();
      projection.fitSize([width, height], combined);
      const path = d3.geoPath().projection(projection);
      
      // Dessiner le fond de carte
      const gBackground = svg.append("g").attr("class", "background-map");
      gBackground.selectAll("path")
        .data(world.features)
        .join("path")
        .attr("d", path)
        .attr("fill", "#eeeeee")
        .attr("stroke", "#999999")
        .attr("stroke-width", 0.5);
      
      // Échelle de couleur pour vos données
      const colorScale = d3.scaleQuantize()
        .domain(d3.extent(geoData.features, d => d.properties.Wsavg))
        .range(["#28a2b7", "#432c39"]);
      
      // Groupe pour dessiner les polygones de vos données
      const gData = svg.append("g").attr("class", "map-layer");
      
      gData.selectAll("path")
        .data(geoData.features)
        .join("path")
        .attr("d", path)
        .attr("fill", d => colorScale(d.properties.Wsavg || 0))
        .attr("stroke", "#ccc")
        .attr("stroke-width", 0.5)
        .on("mouseenter", function(event, d) {
          if (selectEl.value === "all") {
            gData.selectAll("path")
              .style("opacity", f => f === d ? 1 : 0.2);
          }
          tooltip
            .style("visibility", "visible")
            .text(`Wsavg : ${d.properties.Wsavg}`);
        })
        .on("mouseleave", function() {
          if (selectEl.value === "all") {
            gData.selectAll("path").style("opacity", 1);
          }
          tooltip.style("visibility", "hidden");
        })
        .on("click", function(event, d) {
          const zone = d.properties.DRAINAGE || "all";
          selectEl.value = zone;
          updateSelection(zone);
        });
      
      // Ajouter un tooltip dans le SVG
      const tooltip = svg.append("text")
        .attr("class", "tooltip")
        .style("font-family", "sans-serif")
        .style("font-size", "12px")
        .style("pointer-events", "none")
        .style("visibility", "hidden");
      
      // Zoom et Pan
      const zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", event => {
          gBackground.attr("transform", event.transform);
          gData.attr("transform", event.transform);
        });
      svg.call(zoom);
      
      // Fonction de mise à jour de la sélection
      function updateSelection(selectedZone) {
        if (selectedZone === "all" || selectedZone === "") {
          gData.selectAll("path").style("opacity", 1);
        } else {
          gData.selectAll("path")
            .style("opacity", d => d.properties.DRAINAGE === selectedZone ? 1 : 0.2);
          updateCharts(selectedZone.replace(/ RIVER/gi, ""));
        }
      }
      
      // Mettre à jour la sélection lors du changement dans le menu déroulant
      selectEl.addEventListener("change", function() {
        updateSelection(this.value);
      });
      
      return container;
    }

    // Appel de la fonction pour créer et insérer la carte dans le left-container
    (async () => {
      const mapContainer = await createMap10();
      const leftContainer = document.getElementById("left-container");
      leftContainer.innerHTML = ""; // Effacer le contenu existant
      leftContainer.appendChild(mapContainer);
    })();
  </script>

  <!-- Script existant pour les autres graphiques (dans le right-container) -->
  <script>
    Promise.all([
      d3.csv("data/blue_water_footprint.csv"),
      d3.csv("data/blue_water_availability.csv"),
      d3.csv("data/natural_runoff.csv"),
      d3.csv("data/scarcity_csv.csv"),
      d3.csv("data/wiki_link_bassin.csv")
    ]).then(function([footprintData, availabilityData, runoffData, scarcityData, wikiDataLoaded]) {
      wikiData = wikiDataLoaded; // Stocke les données chargées
      // Extraction de la liste des bassins
      const basinNames = footprintData.map(d => d.basin_name).filter(Boolean);
      
      // Création du sélecteur commun
      const selectorContainer = d3.select("#selector-container");
      //const basinSelector = selectorContainer.append("select");
      
      const months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
      const width = 800, height = 500;
      const margin = { top: 60, right: 150, bottom: 50, left: 60 };

      // Fonction pour mettre à jour le lien Wikipédia en fonction du bassin
      function updateWikipediaLink(basinName) {
        const wikiContainer = document.getElementById("wiki-link");
        const wikiEntry = wikiData.find(d => d.basin_name.trim().toLowerCase() === basinName.trim().toLowerCase());
        const url = wikiEntry ? wikiEntry.wikipedia_link : "#";
        wikiContainer.innerHTML = `<a href="${url}" target="_blank">Page Wikipedia de ${basinName}</a>`;
      }
      
      // Fonctions de mise à jour des graphiques (chart6, chart7, chartDiff)
      function updateChart6(basinName) {
        const container = d3.select("#chart6-container");
        container.html("");
        container.append("h2")
          .style("text-align", "center")
          .text("Eau bleu");
        const svg = container.append("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("preserveAspectRatio", "xMidYMid meet");
        
        const footRow = footprintData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase()
);
        const availRow = availabilityData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase()
);
        const runRow = runoffData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase()
);
        
        const footprint = months.map(m => (+footRow?.[m] || 0) / 1e3);
        const availability = months.map(m => +availRow?.[m] || 0);
        const runoff = months.map(m => +runRow?.[m] || 0);
        const allValues = footprint.concat(availability, runoff);
        const yMax = d3.max(allValues);
        
        const x = d3.scalePoint()
          .domain(months)
          .range([margin.left, width - margin.right - 100]);
        const y = d3.scaleLinear()
          .domain([0, yMax]).nice()
          .range([height - margin.bottom, margin.top]);
        
        svg.append("g")
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x));
        svg.append("g")
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y));
        
        const legend = svg.append("g")
          .attr("transform", `translate(${width - margin.right + 10},50)`);
        const colors = { footprint: "steelblue", availability: "green", runoff: "orange" };
        Object.keys(colors).forEach((key, i) => {
          legend.append("rect")
            .attr("x", 0)
            .attr("y", i * 20)
            .attr("width", 12)
            .attr("height", 12)
            .attr("fill", colors[key]);
          legend.append("text")
            .attr("x", 20)
            .attr("y", i * 20 + 10)
            .attr("font-size", "12px")
            .text(key.charAt(0).toUpperCase() + key.slice(1));
        });
        
        const line = d3.line()
          .x((d, i) => x(months[i]))
          .y(d => y(d));
        
        svg.append("path")
          .datum(footprint)
          .attr("fill", "none")
          .attr("stroke", colors.footprint)
          .attr("stroke-width", 2)
          .attr("d", line);
        
        svg.append("path")
          .datum(availability)
          .attr("fill", "none")
          .attr("stroke", colors.availability)
          .attr("stroke-width", 2)
          .attr("d", line);
        
        svg.append("path")
          .datum(runoff)
          .attr("fill", "none")
          .attr("stroke", colors.runoff)
          .attr("stroke-width", 2)
          .attr("d", line);
      }
      
      function updateChart7(basinName) {
        const container = d3.select("#chart7-container");
        container.html("");
        container.append("h2")
          .style("text-align", "center")
          .text("Raretée de l'eau bleu au cours de l'année");
        const svg = container.append("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("preserveAspectRatio", "xMidYMid meet");
        
        const basinEntry = scarcityData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase()
);
        const values = months.map(m => parseFloat(basinEntry?.[m]) || 0);
        const population = basinEntry?.population || "N/A";
        
        container.append("div")
          .attr("class", "info-box")
          .style("left", (width - margin.right) + "px")
          .style("top", "80px")
          .html(`<strong>${basinName}</strong><br>Population: ${population}`);
        
        const x = d3.scalePoint()
          .domain(months)
          .range([margin.left, width - margin.right - 150]);
        const y = d3.scaleLinear()
          .domain([0, d3.max(values)]).nice()
          .range([height - margin.bottom, margin.top]);
        
        svg.append("g")
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x));
        svg.append("g")
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y));
        
        const line = d3.line()
          .x((d, i) => x(months[i]))
          .y(d => y(d));
        
        svg.append("path")
          .datum(values)
          .attr("fill", "none")
          .attr("stroke", "red")
          .attr("stroke-width", 2)
          .attr("d", line);
        
        svg.selectAll(".point")
          .data(values)
          .enter()
          .append("circle")
          .attr("class", "point")
          .attr("r", 4)
          .attr("cx", (d, i) => x(months[i]))
          .attr("cy", d => y(d))
          .attr("fill", "red");
      }
      
    function updateChartDiff(basinName) { 
      const container = d3.select("#chartDiff-container");
      container.html("");
      container.append("h2")
        .style("text-align", "left")
        .text("Surplus et pénurie");
      const svg = container.append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

      const footRow = footprintData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase());
      const availRow = availabilityData.find(d => d.basin_name.toLowerCase() === basinName.toLowerCase());
      const diff = months.map(m => {
        const footVal = +footRow?.[m] || 0;
        const availVal = +availRow?.[m] || 0;
        return availVal - footVal;
      });
      
      // Calcul de la valeur absolue maximale pour centrer zéro
      const maxAbs = d3.max(diff, d => Math.abs(d));
      
      // Définition de l'échelle y avec un domaine symétrique autour de zéro
      const y = d3.scaleLinear()
        .domain([-maxAbs, maxAbs])
        .range([height - margin.bottom, margin.top]);
        
      const x = d3.scalePoint()
        .domain(months)
        .range([margin.left, width - margin.right - 100]);
      
      // Axes
      svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x))
        .append("text")
          .attr("x", (width - margin.left - margin.right) / 2 + margin.left)
          .attr("y", 35)
          .attr("text-anchor", "middle")
          .attr("font-size", "14px")
          .attr("fill", "black")
          .text("Disponibilité mensuelle");
          
      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y));
      
      // Ligne horizontale à y(0)
      svg.append("line")
        .attr("x1", margin.left)
        .attr("x2", width - margin.right)
        .attr("y1", y(0))
        .attr("y2", y(0))
        .attr("stroke", "black")
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "4,2");
      
      // Générateur d'aire (de y(0) jusqu'à y(d))
      const area = d3.area()
        .x((d, i) => x(months[i]))
        .y0(y(0))
        .y1(d => y(d));
      
      // Définition des clip paths pour séparer au niveau de y(0)
      svg.append("clipPath")
        .attr("id", "clip-above")
        .append("rect")
          .attr("x", margin.left)
          .attr("y", margin.top)
          .attr("width", width - margin.left - margin.right)
          .attr("height", y(0) - margin.top);
          
      svg.append("clipPath")
        .attr("id", "clip-below")
        .append("rect")
          .attr("x", margin.left)
          .attr("y", y(0))
          .attr("width", width - margin.left - margin.right)
          .attr("height", height - margin.bottom - y(0));
      
      // Aire au-dessus de zéro en bleu
      svg.append("path")
        .datum(diff)
        .attr("fill", "blue")
        .attr("d", area)
        .attr("clip-path", "url(#clip-above)");
      
      // Aire en dessous de zéro en rouge
      svg.append("path")
        .datum(diff)
        .attr("fill", "red")
        .attr("d", area)
        .attr("clip-path", "url(#clip-below)");
      
      // Ligne du graphique
      const line = d3.line()
        .x((d, i) => x(months[i]))
        .y(d => y(d));
      
      svg.append("path")
        .datum(diff)
        .attr("fill", "none")
        .attr("stroke", "black")
        .attr("stroke-width", 2)
        .attr("d", line);
      
      // (Optionnel) Affichage d'une info-box
      function areaUnderCurve(values) {
        let sum = 0;
        for (let i = 0; i < values.length - 1; i++) {
          sum += (values[i] + values[i+1]) / 2;
        }
        return sum;
      }
      const approxArea = areaUnderCurve(diff);
      
      container.append("div")
        .attr("class", "info-box")
        .style("left", (width/2) + "px")
        .style("top", "10px")
        .html(`<strong>${basinName}</strong><br>Aire sous la courbe (approx) : ${approxArea.toFixed(2)}`);
    }


      function updateCharts(basinName) {
        updateChart6(basinName);
        updateChart7(basinName);
        updateChartDiff(basinName);
        updateWikipediaLink(basinName);
        window.updateCharts = updateCharts;

      }
      
      //basinSelector.on("change", function() {
      //  updateCharts(this.value);
      //});
      
      // Affichage initial avec le premier bassin
      updateCharts(basinNames[0]);
      
    }).catch(function(error) {
      console.error("Erreur lors du chargement des CSV :", error);
    });
  </script>
</body>
</html>
